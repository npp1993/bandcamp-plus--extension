/**
 * Service for helping download Bandcamp purchased tracks
 * Adds a button to generate a cURL script for batch downloading
 */
export class DownloadHelperService {
  private button: HTMLButtonElement;
  private observer: MutationObserver;

  constructor() {
    this.observer = new MutationObserver(this.mutationCallback.bind(this));
  }

  /**
   * Initialize the download helper
   */
  public init(): void {
    console.log('Initiating Download Helper');
    
    this.createButton();
    this.checkDownloadLinks();
    
    // Set up observer to watch for download links becoming available
    const config = { attributes: true, attributeFilter: ['href', 'style'] };
    const targetNodes = document.querySelectorAll('.download-title .item-button');
    
    // Convert NodeList to Array before iteration
    Array.from(targetNodes).forEach(node => {
      this.observer.observe(node, config);
    });
  }

  /**
   * Create the download button and add it to the page
   */
  private createButton(): void {
    if (this.button) return;

    const location = document.querySelector('div.download-titles');
    if (!location) return;

    this.button = document.createElement('button');
    this.button.title = "Generates a file for automating downloads using 'cURL'";
    this.button.className = 'bandcamp-workflow-download-all';
    this.button.disabled = true;
    this.button.textContent = 'Preparing download...';

    location.append(this.button);
  }

  /**
   * Enable the download button when all links are ready
   */
  private enableButton(): void {
    console.log('Enabling download button');
    
    this.button.disabled = false;
    this.button.textContent = 'Download cURL File';
    
    this.button.addEventListener('click', () => {
      const date = this.formatDate();
      const downloadList = this.generateDownloadList();
      const preamble = this.getDownloadPreamble();
      const postamble = this.getDownloadPostamble();
      const downloadDocument = preamble + downloadList + postamble;
      
      this.downloadFile(`bandcamp_${date}.txt`, downloadDocument);
    });
  }

  /**
   * Disable the download button when links are not ready
   */
  private disableButton(): void {
    console.log('Disabling download button');
    
    // Clone the button to remove event listeners
    if (this.button && this.button.parentNode) {
      const newButton = this.button.cloneNode(true) as HTMLButtonElement;
      this.button.parentNode.replaceChild(newButton, this.button);
      this.button = newButton;
    }
    
    this.button.disabled = true;
    this.button.textContent = 'Preparing download...';
  }

  /**
   * Check if download links are ready
   */
  private checkDownloadLinks(): void {
    this.mutationCallback();
  }

  /**
   * Callback for MutationObserver
   */
  private mutationCallback(): void {
    const allDownloadLinks = document.querySelectorAll('.download-title .item-button');
    
    if (allDownloadLinks.length === 0) return;
    
    const linksReady = Array.from(allDownloadLinks).every(
      element => (element as HTMLElement).style.display !== 'none'
    );
    
    console.log(`Download links ready: ${linksReady}`);
    
    if (linksReady) {
      this.enableButton();
    } else {
      this.disableButton();
    }
  }

  /**
   * Generate the list of download URLs
   */
  private generateDownloadList(): string {
    const urlSet = new Set(
      Array.from(document.querySelectorAll('a.item-button')).map(item => 
        item.getAttribute('href')
      ).filter(href => href)
    );
    
    if (urlSet.size === 0) return 'URLS=()\n';
    
    const fileList = Array.from(urlSet).map(url => `\t"${url}"`).join('\n');
    return 'URLS=(\n' + fileList + '\n)\n';
  }

  /**
   * Format the current date for filename
   */
  private formatDate(): string {
    const currentdate = new Date();
    const year = String(currentdate.getFullYear()).slice(-2);
    const month = String(currentdate.getMonth() + 1).padStart(2, '0');
    const day = String(currentdate.getDate()).padStart(2, '0');
    
    return `${year}-${month}-${day}`;
  }

  /**
   * Download a file with the given name and content
   */
  private downloadFile(filename: string, text: string): void {
    const element = document.createElement('a');
    
    element.setAttribute(
      'href',
      'data:text/plain;charset=utf-8,' + encodeURIComponent(text)
    );
    element.setAttribute('download', filename);
    
    element.style.display = 'none';
    document.body.appendChild(element);
    
    element.click();
    
    document.body.removeChild(element);
  }

  /**
   * Get the preamble for the download script
   */
  private getDownloadPreamble(): string {
    return `#!/usr/bin/env bash

# Generated by Bandcamp Workflow Extension
#
# The following can be used to batch download your recent purchases.
# 
# Usage (Mac/Linux):
# 1) open Terminal
# 2) move to desired download directory (e.g. \`cd ~/Downloads/bandcamp\`)
# 3) run script (e.g. \`bash <this filename>.txt\` or \`. ./<this filename>.txt\`)

`;
  }

  /**
   * Get the postamble (implementation) for the download script
   */
  private getDownloadPostamble(): string {
    return `
DEFAULT_BATCH_SIZE=5

download_file() {
    local url="$1"
    
    if curl -L --fail -OJ "$url" 2>/dev/null; then
        echo -n "."
        return 0
    else
        echo -n "x"
        return 1
    fi
}

TOTAL_URLS=\${#URLS[@]}
COMPLETED=0
FAILED=0
BATCH_SIZE=\${1:-$DEFAULT_BATCH_SIZE}
if [ "$BATCH_SIZE" -eq "$DEFAULT_BATCH_SIZE" ] && [ -z "$1" ]; then
    echo "note: the BATCH_SIZE can be set with a numerical argument after the command. e.g. bash this_script.txt 10"
fi

echo "Beginning parallel download of $TOTAL_URLS files (batch size: $BATCH_SIZE)"
for ((i=0; i<TOTAL_URLS; i+=BATCH_SIZE)); do
    pids=()
    for ((j=i; j<i+BATCH_SIZE && j<TOTAL_URLS; j++)); do
        download_file "\${URLS[j]}" &
        pids+=($!)
    done
    
    for pid in "\${pids[@]}"; do
        wait $pid
        status=$?
        if [ $status -eq 0 ]; then
            ((COMPLETED++))
        else
            ((FAILED++))
        fi
    done
done

echo ""
if [ $FAILED -eq 0 ]; then
    echo "Successfully downloaded $TOTAL_URLS files"
else
    echo "$FAILED files failed to download"
fi
echo ""
echo "Press any key to exit..."
read -n 1

exit $FAILED
`;
  }
}